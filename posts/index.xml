<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on alexheretic posts</title><link>https://alexheretic.github.io/posts/</link><description>alexheretic posts (Posts)</description><generator>Hugo -- gohugo.io</generator><language>en-gb</language><lastBuildDate>Wed, 09 Feb 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://alexheretic.github.io/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>AV1 encoding: ab-av1</title><link>https://alexheretic.github.io/posts/ab-av1/</link><pubDate>Wed, 09 Feb 2022 00:00:00 +0000</pubDate><guid>https://alexheretic.github.io/posts/ab-av1/</guid><description>&lt;p>In &lt;a href="https://alexheretic.github.io/posts/av1-p1">my previous post&lt;/a> I looked at video encoding using svt-av1 with &lt;strong>crf&lt;/strong> &amp;amp; &lt;strong>preset&lt;/strong> settings and using VMAF to rate the resultant quality. Av1 encoding is reasonably fast now, but encoding a full video then checking the VMAF potentially multiple times to find a good crf &amp;amp; preset&amp;hellip; that is going to be &lt;em>not so fast&lt;/em>.&lt;/p>
&lt;h2 id="sample-encoding" >Sample encoding
&lt;span>
&lt;a href="#sample-encoding">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h2>&lt;p>My answer was to cut a small section of the &lt;em>vid.mp4&lt;/em> original video, say 20s long, and encode that. It&amp;rsquo;s obviously much faster encoding a short clip, it&amp;rsquo;s also similarly much faster to measure the VMAF. From the clip we can calculate/guess the size of the fully encoded output too. However, the short clip may not be representative of the full video and produce inaccurate VMAF/size.&lt;/p>
&lt;p>But we can improve the accuracy by taking multiple samples considering all of them. It&amp;rsquo;s still way faster to encode &amp;amp; VMAF a bunch of 20s samples than to do the full video.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-text" data-lang="text">vid.mp4
+--------------------------------------------------------------------------------+
| |A| |B| |C| |
+--------------------------------------------------------------------------------+
| | |
v v v
cut 20s vid.a.mp4 vid.b.mp4 vid.c.mp4
| | |
v v v
encode vid.a.av1.mp4 vid.b.av1.mp4 vid.c.av1.mp4
&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>Cut &lt;em>vid.mp4&lt;/em> into 3 20s samples spaced throughout the full video (a, b &amp;amp; c). This is done with ffmpeg and is a comparatively instant operation.&lt;/li>
&lt;li>Encode each sample using svt-av1.&lt;/li>
&lt;li>Calculate VMAF score for each sample.&lt;/li>
&lt;/ul>
&lt;p>Then from the samples we can calculate the mean VMAF and size diff. We can use this to predict what the full video size &amp;amp; VMAF would be after a (potentially lengthy) full encode.&lt;/p>
&lt;p>While it&amp;rsquo;s easy enough to cut a sample using ffmpeg the whole process got complicated enough that I wrote a CLI program to help me.&lt;/p>
&lt;h2 id="ab-av1" >ab-av1
&lt;span>
&lt;a href="#ab-av1">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h2>&lt;p>&lt;strong>ab-av1&lt;/strong> (&lt;a href="https://github.com/alexheretic/ab-av1#readme">github&lt;/a>, &lt;a href="https://aur.archlinux.org/packages/ab-av1">AUR&lt;/a>) is a rust CLI binary that I wrote to handle sample encoding &lt;em>(and more)&lt;/em>. It calls out to ffmpeg &amp;amp; svt-av1 as child processes to do the actual cutting, encoding and VMAFing.&lt;/p>
&lt;p>ab-av1 has functionality split into subcommands. The first one I wrote handles sample encoding.&lt;/p>
&lt;h3 id="ab-av1-sample-encode" >ab-av1 sample-encode
&lt;span>
&lt;a href="#ab-av1-sample-encode">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h3>&lt;blockquote>
&lt;p>Encode short video samples of an input using provided crf &amp;amp; preset. This is much quicker than full encode/vmaf run.&lt;/p>
&lt;/blockquote>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-text" data-lang="text">ab-av1 sample-encode [OPTIONS] -i &amp;lt;INPUT&amp;gt; --crf &amp;lt;CRF&amp;gt; --preset &amp;lt;PRESET&amp;gt;
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Let&amp;rsquo;s give it a bash on the same &lt;em>vid.mp4&lt;/em> we used previously.&lt;/p>
&lt;p>&lt;video src="ab-av1-sample-encode.mp4" poster="ab-av1-sample-encode.avif" playsinline controls>&lt;/video>&lt;/p>
&lt;p>So from the 3 samples we can predict VMAF &lt;strong>96.36&lt;/strong> and a &lt;strong>59% encoded size&lt;/strong>. Since already fully encoded this video with these settings we know that real result was VMAF &lt;strong>96.04&lt;/strong> with &lt;strong>66%&lt;/strong> size. So we can see the predictions are indeed approximate. But the big difference is we did our prediction in &lt;strong>19 seconds&lt;/strong> vs ~13 minutes.&lt;/p>
&lt;p>We can always up the sample count if we suspect our video to be more variable. E.g. if I&amp;rsquo;d used 8 samples above it would have taken 47 seconds to predict VMAF &lt;strong>96.04&lt;/strong> with &lt;strong>68%&lt;/strong> size, which is &lt;em>very&lt;/em> close to the truth and still a lot faster than encoding the whole thing.&lt;/p>
&lt;p>With &lt;strong>sample-encode&lt;/strong> we now have a fast &amp;amp; convenient way to how analyse any svt-av1 crf and preset setting. We can now start using it to search for the highest crf that achieves a given VMAF score. Naturally ab-av1 has a subcommand for this.&lt;/p>
&lt;h3 id="ab-av1-crf-search" >ab-av1 crf-search
&lt;span>
&lt;a href="#ab-av1-crf-search">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h3>&lt;blockquote>
&lt;p>Interpolated binary search using sample-encode to find the best crf value delivering &lt;strong>min-vmaf&lt;/strong> &amp;amp; &lt;strong>max-encoded-percent&lt;/strong>.&lt;/p>
&lt;/blockquote>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-text" data-lang="text">ab-av1 crf-search [OPTIONS] -i &amp;lt;INPUT&amp;gt; --preset &amp;lt;PRESET&amp;gt;
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Let&amp;rsquo;s try it out by searching for the best crf for &lt;em>vid.mp4&lt;/em> to get VMAF 94.&lt;/p>
&lt;p>&lt;img src="ab-av1-crf-search.png" alt="">&lt;/p>
&lt;p>The command called sample-encode 4 times as it searched for the highest crf to satisfy our VMAF constraint. It tells us that if we can up our crf to &lt;strong>36&lt;/strong> to get our desired quality. Higher crf means our output is will be even smaller. It also predicts how long the full encode will take, ~6 minutes, which we already know is pretty close to the truth.&lt;/p>
&lt;p>Because sample-encode itself is so fast the entire crf-search took only around a minute. Of course this will slow down with lower presets, but should always be proportionally much quicker than doing a full encode.&lt;/p>
&lt;h2 id="evaluating-svt-av1-presets" >Evaluating svt-av1 presets
&lt;span>
&lt;a href="#evaluating-svt-av1-presets">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h2>&lt;p>ab-av1 provides a way to take an objective look at svt-av1 presets and to do it in &lt;em>a single human lifetime&lt;/em>. We already know lower presets are higher quality and take longer, but how high and how long?&lt;/p>
&lt;p>Well lower presets are &lt;em>very&lt;/em> slow indeed. It&amp;rsquo;s also true that all presets produce roughly the same size output on a given crf. So we need to get a VMAF score to show the true value.&lt;/p>
&lt;p>&lt;strong>crf-search&lt;/strong> can do this, if the preset gives better quality we should be able to find a higher crf value to satisfy our VMAF constraint.&lt;/p>
&lt;p>&lt;img src="ab-av1-presets.png" alt="" title="For presets under 4 even the sample encodes take forever">&lt;/p>
&lt;p>And indeed this is the case. We can use higher crf values to achieve VMAF 94 as we use lower presets. From this example preset &lt;strong>6&lt;/strong> seems a good compromise between speed and quality.&lt;/p>
&lt;h2 id="ab-av1-extras" >ab-av1: extras
&lt;span>
&lt;a href="#ab-av1-extras">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h2>&lt;p>&lt;strong>sample-encode&lt;/strong> &amp;amp; &lt;strong>crf-search&lt;/strong> are the &amp;ldquo;guts&amp;rdquo; of ab-av1, but it also comes with some other commands that make use of, or can be used alongside, those. They are at least more ergonomic that using ffmpeg directly and have nice progress bars.&lt;/p>
&lt;ul>
&lt;li>&lt;strong>auto-encode&lt;/strong> &lt;em>Automatically determine the best crf to deliver the min-vmaf and use it to encode a video.&lt;/em>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-text" data-lang="text">ab-av1 auto-encode [OPTIONS] -i &amp;lt;INPUT&amp;gt; --preset &amp;lt;PRESET&amp;gt;
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>&lt;strong>encode&lt;/strong> &lt;em>Simple invocation of ffmpeg &amp;amp; SvtAv1EncApp to encode a video.&lt;/em>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-text" data-lang="text">ab-av1 encode [OPTIONS] -i &amp;lt;INPUT&amp;gt; --crf &amp;lt;CRF&amp;gt; --preset &amp;lt;PRESET&amp;gt;
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>&lt;strong>vmaf&lt;/strong> &lt;em>Simple full calculation of VMAF score distorted file vs original file.&lt;/em>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-text" data-lang="text">ab-av1 vmaf --original &amp;lt;ORIGINAL&amp;gt; --distorted &amp;lt;DISTORTED&amp;gt;
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ul>
&lt;p>If you have ideas to improve ab-av1, come on over and raise an issue at &lt;a href="https://github.com/alexheretic/ab-av1">alexheretic/ab-av1&lt;/a>.&lt;/p>
&lt;h2 id="further-reading-av1an" >Further reading: av1an
&lt;span>
&lt;a href="#further-reading-av1an">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h2>&lt;p>You should also be aware of the more ambitious project &lt;a href="https://github.com/master-of-zen/Av1an">av1an&lt;/a>, it&amp;rsquo;s also a rust CLI wrapper that controls child processes. It also supports encoding to a &amp;ldquo;target-quality&amp;rdquo; VMAF score.&lt;/p>
&lt;p>However, I found it&amp;rsquo;s VMAF analysis to be too slow for my patience, hence my investigation into sample encoding &amp;amp; VMAF. I also find svt-av1 to do good enough threading on its own, so don&amp;rsquo;t benefit too much from the chunk-based concurrent encoding av1an provides &lt;em>(though libaom &amp;amp; other encoders are perhaps a different story)&lt;/em>.&lt;/p></description></item><item><title>AV1 encoding: SVT-AV1 &amp; VMAF</title><link>https://alexheretic.github.io/posts/av1-p1/</link><pubDate>Sun, 06 Feb 2022 00:00:00 +0000</pubDate><guid>https://alexheretic.github.io/posts/av1-p1/</guid><description>&lt;p>I&amp;rsquo;ve been experimenting with av1 video encoding for a while now. Av1 is a royalty free video codec set to replace existing codecs with better quality and/or lower bitrates. Support for it is somewhat decent now. Back when I first tried it I found the encoding speed (using the reference encoder libaom) to be just too slow.&lt;/p>
&lt;p>However, I later read about the &lt;a href="https://gitlab.com/AOMediaCodec/SVT-AV1">svt-av1&lt;/a> encoder over at &lt;a href="https://www.phoronix.com">phoronix&lt;/a> which offers much faster encoding. More recently svt-av1 &lt;strong>v0.9&lt;/strong> has released and &lt;a href="https://www.phoronix.com/scan.php?page=article&amp;amp;item=svt-av1-09&amp;amp;num=1">is even faster&lt;/a>. So I think we&amp;rsquo;re at the point where av1 encoding is now fast enough for mortals like me to actually use.&lt;/p>
&lt;h2 id="re-encoding-h264--friends" >Re-encoding h264 &amp;amp; friends
&lt;span>
&lt;a href="#re-encoding-h264--friends">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h2>&lt;p>A fair test of a codec is to take a high quality original compare an encoding using av1 and one using h264 (or whatever). However, in reality I have a bunch of already h264-ed videos with no high-quality originals. Av1 in many cases can do a much harder feat in re-encoding h264 to a significantly smaller size without perceptible quality loss.&lt;/p>
&lt;p>Lets re-encode a ~35 minute 854x480 h264 video as an example. First you&amp;rsquo;ll need svt-av1 &amp;amp; ffmpeg installed.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-sh" data-lang="sh">sudo pacman -Syu svt-av1 ffmpeg
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Then we can use them to re-encode &lt;em>vid.mp4&lt;/em>.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-sh" data-lang="sh">ffmpeg -loglevel error -i vid.mp4 -pix_fmt yuv420p10le -strict -1 -f yuv4mpegpipe - &lt;span style="color:#ae81ff">\
&lt;/span>&lt;span style="color:#ae81ff">&lt;/span> | SvtAv1EncApp -i stdin --crf &lt;span style="color:#ae81ff">32&lt;/span> --preset &lt;span style="color:#ae81ff">8&lt;/span> --input-depth &lt;span style="color:#ae81ff">10&lt;/span> -b stdout &lt;span style="color:#ae81ff">\
&lt;/span>&lt;span style="color:#ae81ff">&lt;/span> | ffmpeg -i - -i vid.mp4 -map 0:v -map 1:a:0 -c:a copy -c:v copy vid.av1.mp4
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Here we&amp;rsquo;re doing 3 commands each piping into the next:&lt;/p>
&lt;ul>
&lt;li>Use ffmpeg to convert &lt;em>vid.mp4&lt;/em> into a format that svt-av1 can encode &lt;em>(using 10-bit over 8-bit as it&amp;rsquo;s generally recommended)&lt;/em>.&lt;/li>
&lt;li>Use svt-av1 to encode the stream using a &lt;strong>crf&lt;/strong> (quality) and &lt;strong>preset&lt;/strong> (encoder speed) setting we just made up.&lt;/li>
&lt;li>Finally use ffmpeg again to take the av1 data stream and combine with the original audio into a new &lt;em>vid.av1.mp4&lt;/em> file.&lt;/li>
&lt;/ul>
&lt;p>On my 5800x this takes &lt;strong>~7 minutes&lt;/strong>, so pretty fast, and encodes down to &lt;strong>66% original size&lt;/strong>. When I look at both side by side they seem the same quality. That&amp;rsquo;s great! &amp;hellip;But I wonder if we can do better.&lt;/p>
&lt;p>The most important settings above are the &lt;strong>crf&lt;/strong> &amp;amp; &lt;strong>preset&lt;/strong>.&lt;/p>
&lt;ul>
&lt;li>&lt;strong>preset&lt;/strong> (0-13) is how fast the encoder works, higher values mean faster encodes but with lower quality.&lt;/li>
&lt;li>&lt;strong>crf&lt;/strong> is &amp;ldquo;constant rate factor&amp;rdquo; (1-63), higher values mean lower quality &amp;amp; lower size.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>preset&lt;/strong> values seem to work pretty consistently across all videos. You can pick a preset based on how impatient you are. My rough guide would be pick &lt;strong>6&lt;/strong> if &lt;strong>4&lt;/strong> is too slow for you, &lt;strong>8&lt;/strong> if &lt;strong>6&lt;/strong> is.&lt;/p>
&lt;p>&lt;strong>crf&lt;/strong> is trickier. The &amp;ldquo;right&amp;rdquo; setting will be different for how high quality you want, obviously, but it&amp;rsquo;s also different video to video, particularly across video resolutions.&lt;/p>
&lt;p>If we have time we can try more crf (and preset) values and check if the quality is good enough. But it&amp;rsquo;s slow, boring and inconsistent to compare videos manually with my actual eyes. It would be nice if we had a way to check the quality of the result eyelessly.&lt;/p>
&lt;h2 id="vmaf" >VMAF
&lt;span>
&lt;a href="#vmaf">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h2>&lt;p>VMAF is a video quality metric we can use to do that. You give it two videos and it&amp;rsquo;ll give you a score (0-100) of how close the distorted was to the original, 100 being perfect.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-sh" data-lang="sh">sudo pacman -Syu vmaf
&lt;/code>&lt;/pre>&lt;/div>&lt;p>We can use this (via ffmpeg) to test our &lt;em>vid.av1.mp4&lt;/em>.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-sh" data-lang="sh">ffmpeg -i vid.av1.mp4 -i vid.mp4 -lavfi libvmaf -f null -
&lt;/code>&lt;/pre>&lt;/div>&lt;p>This produces a VMAF score of &lt;strong>96.044922&lt;/strong>. So supports what my eyes thought &lt;em>vid.av1.mp4&lt;/em> is very similar to the h264 &lt;em>vid.mp4&lt;/em>. It also suggests we could get the av1 version even smaller and achieve, say, VMAF 95.&lt;/p>
&lt;p>Now we have the tools to test different &lt;strong>crf&lt;/strong> values to find the highest that gives us a given VMAF score. We can try different &lt;strong>preset&lt;/strong> values too.&lt;/p>
&lt;p>The catch is VMAF itself isn&amp;rsquo;t super fast. The run above took ~6 minutes using all my cores. So testing another crf will take another 13 minutes or so. If we try lower presets it&amp;rsquo;ll take longer to encode. And of course this is with a shortish low resolution video, longer 1080p or 4k videos will take ages.&lt;/p>
&lt;p>In the next post I&amp;rsquo;ll talk about a way to get &lt;strong>much faster VMAF scores&lt;/strong> for any given svt-av1 crf &amp;amp; preset.&lt;/p></description></item><item><title>Game years</title><link>https://alexheretic.github.io/posts/games/</link><pubDate>Sat, 05 Feb 2022 00:00:00 +0000</pubDate><guid>https://alexheretic.github.io/posts/games/</guid><description>&lt;p>In 2017 I quit my job to make a PC programming puzzle game &lt;a href="https://www.roboinstruct.us">&lt;strong>Robo Instructus&lt;/strong>&lt;/a>.&lt;/p>
&lt;p>&lt;img src="steam-robo-instructus.webp" alt="">&lt;/p>
&lt;p>One aspect in particular I worked on in some depth was &lt;strong>text rendering&lt;/strong>. Robo Instructus has a lot of text &amp;amp; there just wasn&amp;rsquo;t the libraries in the Rust ecosystem that could perform as I needed, particularly compiled in debug mode &lt;em>(and I&amp;rsquo;m not waiting for rust &amp;ndash;release compiles after each code change!)&lt;/em>.&lt;/p>
&lt;p>So I took over maintenance of &lt;a href="https://gitlab.redox-os.org/redox-os/rusttype">rusttype&lt;/a> and fixed my issues with it &amp;amp; its &amp;ldquo;gpu cache&amp;rdquo; module. I eventually rewrote it as &lt;a href="https://github.com/alexheretic/ab-glyph">ab-glyph&lt;/a>. With that as a base I also wrote the &lt;a href="https://github.com/alexheretic/glyph-brush">glyph-brush&lt;/a> crates which handle layout, clever caching and optimise the process of getting text strings into vertices pointing a subtextures on your GPU.&lt;/p>
&lt;p>My open source libs allowed me to handle the profusion of text in my game, I&amp;rsquo;ve also seen them used in other rust game projects &amp;amp; engines which is nice! However, text rendering is surprisingly deep &amp;amp; complex so I&amp;rsquo;ve no doubt superior tools will appear in the rust ecosystem in time.&lt;/p>
&lt;p>I wrote about some of my text rendering adventures on the game blog:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://blog.roboinstruct.us/2018/05/18/technical-look-at-text-rendering-in-robo-instructus.html">2018: Technical Look At Text Rendering In Robo Instructus&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://blog.roboinstruct.us/2018/05/25/technical-look-at-text-rendering-in-robo-instructus-ii.html">2018: Faster Screen Text Rendering&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://blog.roboinstruct.us/2020/05/24/the-otf-journey.html">2020: Otf Font Rendering or: How I Should Have Learned To Stop Worrying And Love The Ttf&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>&lt;a href="https://blog.roboinstruct.us/2020/05/24/the-otf-journey.html">&lt;img src="https://blog.roboinstruct.us/assets/2020-05-23/q-c-beziers.png" alt="">&lt;/a>&lt;/p>
&lt;p>You can read more over at &lt;a href="https://blog.roboinstruct.us">blog.roboinstruct.us&lt;/a>.&lt;/p></description></item></channel></rss>